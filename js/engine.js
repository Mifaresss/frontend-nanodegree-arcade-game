/* Engine.js
 * Этот файл обеспечивает функциональность игрового цикла (обновление сущностей и рендеринг),
  * рисует начальное игровое поле на экране, а затем вызывает обновление и
  * методы рендеринга вашего игрока и вражеских объектов (определены в вашем app.js).
  *
  * Игровой движок работает, рисуя весь игровой экран снова и снова.
  * как флипбук, который вы, возможно, создали в детстве. Когда ваш игрок перемещается
  * на экране может показаться, что изображение/персонаж движется или движется
  * нарисовано, но это не так. На самом деле происходит вся "сцена"
  * рисуется снова и снова, создавая иллюзию анимации.
  *
  * Этот движок делает объект контекста холста (ctx) глобально доступным для создания
  * Написание app.js немного упрощает работу.
 */

var Engine = (function(global) {
  /* Предварительно определите переменные, которые мы будем использовать в этой области,
    * создайте элемент холста, возьмите 2D-контекст для этого холста
    * установить высоту/ширину элемента холста и добавить его в DOM.
   */
  var doc = global.document,
      win = global.window,
      canvas = doc.createElement('canvas'),
      ctx = canvas.getContext('2d'),
      lastTime;

  canvas.width = 505;
  canvas.height = 606;
  doc.body.appendChild(canvas);

  /* Эта функция служит отправной точкой для самого игрового цикла
    * и корректно обрабатывает вызовы методов update и render.
    */
  function main() {
      /* Получите информацию о разнице во времени, которая требуется, если ваша игра
        * требует плавной анимации. Потому что каждый компьютер обрабатывает
        * инструкции на разных скоростях нам нужно постоянное значение, которое
        * будет одинаковым для всех (независимо от того, насколько быстро их
        * комп есть) - ура время!
        */
      var now = Date.now(),
          dt = (now - lastTime) / 1000.0;

      /* Вызываем наши функции обновления/рендеринга, передаем дельту времени в
        * наша функция обновления, поскольку ее можно использовать для плавной анимации.
        */
      update(dt);
      render();

      /* Устанавливаем нашу переменную lastTime, которая используется для определения дельты времени
        * при следующем вызове этой функции.
        */
      lastTime = now;

      /* Используйте функцию браузера requestAnimationFrame для вызова этого
        * работать снова, как только браузер сможет отрисовать другой кадр.
        */
      win.requestAnimationFrame(main);
  }

  /* Эта функция выполняет некоторую первоначальную настройку, которая должна произойти только один раз,
    * в частности установка переменной lastTime, которая требуется для
    * игровой цикл.
    */
  function init() {
      reset();
      lastTime = Date.now();
      main();
  }

  /* Эта функция вызывается main (наш игровой цикл) и сама вызывает все
    * функций, которые могут потребоваться для обновления данных сущности. Основываясь на том, как
    * вы реализуете обнаружение столкновений (когда два объекта занимают
    * то же место, например, когда ваш персонаж должен умереть), вы можете найти
    * необходимость добавить сюда дополнительный вызов функции. На данный момент мы оставили
    * это закомментировано - вы можете или не хотите реализовывать это
    * функциональность таким образом (вы можете просто реализовать обнаружение столкновений
    * на самих объектах в вашем файле app.js).
    */
  function update(dt) {
      updateEntities(dt);
      // checkCollisions();
  }

  /* Это вызывается функцией обновления и перебирает все
    * объекты в вашем массиве allEnemies, как определено в app.js и вызовах
    * их методы update(). Затем он вызовет функцию обновления для вашего
    * объект игрока. Эти методы обновления должны быть сосредоточены исключительно на обновлении
    * данные/свойства, относящиеся к объекту. Сделайте свой рисунок в вашем
    * Методы визуализации.
    */
  function updateEntities(dt) {
      allEnemies.forEach(function(enemy) {
          enemy.update(dt);
      });
      player.update();
  }

  /* Эта функция сначала отрисовывает «уровень игры», затем вызывается
    * Функция renderEntities. Помните, что эта функция вызывается каждый
    * игровой тик (или цикл игрового движка), потому что так работают игры -
    * это флипбуки, создающие иллюзию анимации, но на самом деле
    * они просто рисуют весь экран снова и снова.
    */
  function render() {
      /* This array holds the relative URL to the image used
       * for that particular row of the game level.
       */
      var rowImages = [
              'images/water-block.png',   // Top row is water
              'images/stone-block.png',   // Row 1 of 3 of stone
              'images/stone-block.png',   // Row 2 of 3 of stone
              'images/stone-block.png',   // Row 3 of 3 of stone
              'images/grass-block.png',   // Row 1 of 2 of grass
              'images/grass-block.png'    // Row 2 of 2 of grass
          ],
          numRows = 6,
          numCols = 5,
          row, col;

      // Перед рисованием очищаем существующий холст
      ctx.clearRect(0,0,canvas.width,canvas.height);

      /* Цикл по количеству строк и столбцов, которые мы определили выше
        * и, используя массив rowImages, нарисуйте правильное изображение для этого
        * часть "сетки"
        */
      for (row = 0; row < numRows; row++) {
          for (col = 0; col < numCols; col++) {
              /* Функция drawImage элемента контекста холста
                * требует 3 параметра: изображение для рисования, координата x
                *, чтобы начать рисовать, и координата y, чтобы начать рисовать.
                * Мы используем помощников Resources для ссылок на наши изображения.
                * так что мы получаем преимущества кэширования этих изображений, так как
                * мы используем их снова и снова.
                */
              ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);
          }
      }

      renderEntities();
  }

  /* Эта функция вызывается функцией рендеринга и вызывается в каждой игре
    * поставить галочку. Его цель состоит в том, чтобы затем вызвать функции рендеринга, которые вы определили.
    * на ваших врагах и игроках в app.js
    */
  function renderEntities() {
      /* Перебираем все объекты в массиве allEnemies и вызываем
        * функция рендеринга, которую вы определили.
        */
      allEnemies.forEach(function(enemy) {
          enemy.render();
      });

      player.render();
  }

  /* Эта функция ничего не делает, но могла бы быть хорошим местом для
    * обрабатывать состояния сброса игры - может быть, новое игровое меню или экран окончания игры
    * подобные вещи. Он вызывается только один раз методом init().
    */
  function reset() {
      // noop
  }

  /* Идем дальше и загружаем все изображения, которые, как мы знаем, нам понадобятся
    * Нарисуйте наш уровень игры. Затем установите init в качестве метода обратного вызова, чтобы при
    * все эти изображения правильно загружены, наша игра запустится.
    */
  Resources.load([
      'images/stone-block.png',
      'images/water-block.png',
      'images/grass-block.png',
      'images/enemy-bug.png',
      'images/char-horn-girl.png'
  ]);
  Resources.onReady(init);

  /* Присвоить объект контекста холста глобальной переменной (окну
    * объект при запуске в браузере), чтобы разработчикам было проще его использовать
    * из своих файлов app.js.
    */
  global.ctx = ctx;
})(this);
